"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PixAIClient = exports.isErrorEvent = exports.isCloseEvent = exports.isEvent = exports.PixAIApiError = void 0;
const rxjs_1 = require("rxjs");
const graphql_1 = require("./generated/graphql");
const websocket_1 = require("./websocket");
class PixAIApiError extends Error {
}
exports.PixAIApiError = PixAIApiError;
const isEvent = (e) => {
    return e != null && typeof e === 'object' && 'target' in e;
};
exports.isEvent = isEvent;
const isCloseEvent = (e) => {
    return (0, exports.isEvent)(e) && 'code' in e && 'reason' in e;
};
exports.isCloseEvent = isCloseEvent;
const isErrorEvent = (e) => {
    return (0, exports.isEvent)(e) && 'message' in e;
};
exports.isErrorEvent = isErrorEvent;
class PixAIClient {
    constructor(opt) {
        this.opt = opt;
        this.userAgent = 'PixAIApiClient/1.0.0';
        this.graphqlWsClients = new Set();
        this.subscriptionRequest = (query, variables) => {
            return new rxjs_1.Observable(subscriber => {
                const graphqlWsClient = (0, websocket_1.createRestartableClient)({
                    webSocketImpl: this.opt.webSocketImpl,
                    url: `${this.webSocketBaseUrl}/graphql`,
                    connectionParams: () => {
                        return {
                            token: this.opt.apiKey,
                        };
                    },
                });
                this.graphqlWsClients.add(graphqlWsClient);
                graphqlWsClient.subscribe({
                    query,
                    variables: variables,
                }, {
                    next: data => {
                        if (data.errors) {
                            const err = new PixAIApiError(data.errors[0].message);
                            err.errors = data.errors;
                            subscriber.error(err);
                        }
                        else if (data.data) {
                            subscriber.next(data.data);
                        }
                    },
                    error: e => {
                        if (e instanceof Error) {
                            subscriber.error(e);
                        }
                        else if ((0, exports.isCloseEvent)(e)) {
                            const err = new PixAIApiError(`WebSocket closed: ${e.reason}`);
                            subscriber.error(err);
                        }
                        else if ((0, exports.isErrorEvent)(e)) {
                            subscriber.error(new Error(`WebSocket error: ${e.message}`));
                        }
                        else {
                            subscriber.error(new Error(`Unknown error: ${e}`));
                        }
                    },
                    complete: () => {
                        subscriber.complete();
                    },
                });
            });
        };
        this.normalRequest = async (query, variables) => {
            const res = await this.fetch(`${this.apiBaseUrl}/graphql`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${this.opt.apiKey}`,
                    'User-Agent': this.userAgent,
                },
                body: JSON.stringify({
                    query,
                    variables,
                }),
            });
            const data = await res.json();
            if (data.message) {
                const err = new PixAIApiError(data.message);
                err.status = res.status;
                err.response = res;
                throw err;
            }
            if (data.errors?.length) {
                const err = new PixAIApiError(data.errors[0].message);
                err.errors = data.errors;
                err.status = res.status;
                err.response = res;
                throw err;
            }
            return data.data;
        };
        this.sendRawRequest = function (doc, variables) {
            if (doc.trimStart().startsWith('subscription')) {
                return this.subscriptionRequest(doc, variables);
            }
            return this.normalRequest(doc, variables);
        };
        this.rawSdk = (0, graphql_1.getSdk)(this.sendRawRequest.bind(this));
    }
    get apiBaseUrl() {
        return this.opt.apiBaseUrl || 'https://api.pixai.art';
    }
    get webSocketBaseUrl() {
        return this.opt.webSocketBaseUrl || 'wss://gw.pixai.art';
    }
    get fetch() {
        return this.opt.fetch || globalThis.fetch;
    }
    get $personalEvents() {
        if (!this._$personalEvents) {
            this._$personalEvents = this.rawSdk.subscribePersonalEvents({});
        }
        return this._$personalEvents;
    }
    close() {
        for (const client of this.graphqlWsClients) {
            client.terminate();
        }
        this.graphqlWsClients.clear();
    }
    async createGenerationTask(parameters) {
        const { createGenerationTask } = await this.rawSdk.createGenerationTask({
            parameters,
        });
        return createGenerationTask;
    }
    async cancelGenerationTask(id) {
        const { cancelGenerationTask } = await this.rawSdk.cancelGenerationTask({
            id,
        });
        return cancelGenerationTask;
    }
    async getTaskById(id) {
        const { task } = await this.rawSdk.getTaskById({
            id,
        });
        return task;
    }
    async generateImage(parameters, options = {}) {
        const task = await this.createGenerationTask(parameters);
        if (!task)
            throw new PixAIApiError('Failed to create generation task with unknown error.');
        const { onUpdate } = options;
        const $taskUpdated = this.$personalEvents.pipe((0, rxjs_1.map)(event => event.personalEvents?.taskUpdated), (0, rxjs_1.filter)(taskUpdated => taskUpdated?.id === task.id));
        const subscription = onUpdate && $taskUpdated.subscribe(onUpdate);
        const $taskCompleted = $taskUpdated.pipe((0, rxjs_1.filter)(task => task.status === 'completed'));
        const result = await (0, rxjs_1.firstValueFrom)($taskCompleted);
        subscription?.unsubscribe();
        return result;
    }
    async getUploadUrl(type, provider) {
        const { uploadMedia: { uploadUrl, externalId }, } = await this.rawSdk.uploadMedia({
            input: {
                type,
                provider,
            },
        });
        if (!uploadUrl)
            throw new Error('Upload url is not specified');
        return {
            uploadUrl,
            externalId,
        };
    }
    async registerMedia(input) {
        const { uploadMedia } = await this.rawSdk.uploadMedia({
            input,
        });
        return uploadMedia;
    }
    async uploadMediaFile(file) {
        const provider = graphql_1.MediaProvider.S3;
        const type = file.type.startsWith('image')
            ? graphql_1.MediaType.Image
            : file.type.startsWith('video')
                ? graphql_1.MediaType.Video
                : undefined;
        if (!type) {
            throw new Error(`Unsupported media type ${type}`);
        }
        const { uploadUrl, externalId } = await this.getUploadUrl(type, provider);
        if (!uploadUrl) {
            throw new Error('Upload url is not specified');
        }
        const formData = new FormData();
        formData.append('file', file);
        const init = type === graphql_1.MediaType.Image && provider !== graphql_1.MediaProvider.S3
            ? {
                method: 'POST',
                body: formData,
            }
            : {
                method: 'PUT',
                body: file,
            };
        await fetch(uploadUrl, init);
        return await this.uploadMedia({
            type,
            provider,
            externalId: externalId ?? undefined,
        });
    }
    async uploadMediaUrl(url) {
        const res = await fetch(url);
        const blob = await res.blob();
        const filename = url.split('/').pop() ?? 'file';
        const file = new File([blob], filename, {
            type: blob.type,
        });
        return await this.uploadMediaFile(file);
    }
    async uploadMedia(input) {
        if (typeof input === 'string') {
            return this.uploadMediaUrl(input);
        }
        if (input instanceof File) {
            return this.uploadMediaFile(input);
        }
        return this.registerMedia(input);
    }
    async getMediaById(id) {
        const { media } = await this.rawSdk.getMediaById({
            id,
        });
        return media;
    }
    getPublicUrl(media) {
        return media.urls?.find(url => url.variant === 'PUBLIC')?.url;
    }
    async downloadMedia(media) {
        const url = this.getPublicUrl(media);
        if (!url) {
            throw new Error('Public url is not available');
        }
        const res = await fetch(url);
        return res.arrayBuffer();
    }
    async getMediaFromTask(task) {
        if (task.status !== 'completed') {
            throw new Error('Task is not completed');
        }
        if (Array.isArray(task.outputs?.batch)) {
            return await Promise.all(task.outputs.batch.map(async (i) => {
                return this.getMediaById(i.mediaId);
            }));
        }
        return await this.getMediaById(task.outputs?.mediaId);
    }
}
exports.PixAIClient = PixAIClient;
//# sourceMappingURL=client.js.map